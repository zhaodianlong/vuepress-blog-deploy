(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{320:function(t,e,a){"use strict";a.r(e);var v=a(16),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"vue-双向数据绑定原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-双向数据绑定原理"}},[t._v("#")]),t._v(" Vue 双向数据绑定原理")]),t._v(" "),a("p",[t._v("当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使Object.defineProperty 把这些属性全部转为 getter/setter。每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。这就是所谓的观察者-订阅者模式。")]),t._v(" "),a("blockquote",[a("p",[t._v("vue 3.x 重写的数据劫持函数，使用ES6的语法Proxy，可以检测到数组内部数据的变化。")])]),t._v(" "),a("h2",{attrs:{id:"vue-组件生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件生命周期"}},[t._v("#")]),t._v(" Vue 组件生命周期")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://q39sih9pm.bkt.clouddn.com/lifecycle.png",alt:"生命周期"}})]),t._v(" "),a("h2",{attrs:{id:"created-和-mounted-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#created-和-mounted-的区别"}},[t._v("#")]),t._v(" created 和 mounted 的区别")]),t._v(" "),a("ul",[a("li",[t._v("created 渲染前的操作，此时el还是undefined，data已经存在。这里不能对dom进行操作,常在created调用请求数据函数。")]),t._v(" "),a("li",[t._v("mounted 渲染完成后的操作，此时el，data都已经加载完成，一般对dom的操作都写在mounted中，例如获取innerHTML，初始化echarts的时候。")])]),t._v(" "),a("h2",{attrs:{id:"slot-插槽分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#slot-插槽分类"}},[t._v("#")]),t._v(" slot 插槽分类")]),t._v(" "),a("ul",[a("li",[t._v("匿名插槽 组件中，匿名插槽只能有一个")]),t._v(" "),a("li",[t._v("具名插槽 组件中，具名插槽可有有多个，以name来定义")]),t._v(" "),a("li",[t._v("作用域插槽 slot-scope 访问子组件中才有的数据")])]),t._v(" "),a("h2",{attrs:{id:"组件间传值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件间传值"}},[t._v("#")]),t._v(" 组件间传值")]),t._v(" "),a("ul",[a("li",[t._v("父组件 =》子组件：通过属性进行传值，父组件中定义属性，子组件props接收。")]),t._v(" "),a("li",[t._v("子组件 =》父组件：子组件通过$emit传递数据，父组件通过$on接受。")]),t._v(" "),a("li",[t._v("兄弟组件：使用eventbus事件总线，在代码中创建一个空白的vue实例，所有事件派发和监听都在此实例上进行。")])]),t._v(" "),a("h2",{attrs:{id:"computed-与-methods-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-与-methods-区别"}},[t._v("#")]),t._v(" computed 与 methods 区别")]),t._v(" "),a("ul",[a("li",[t._v("computed 计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。")]),t._v(" "),a("li",[t._v("methods 只有在函数调用时，数据才会改变，不能自动同步数据。")])]),t._v(" "),a("h2",{attrs:{id:"组件中data为什么是个函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件中data为什么是个函数"}},[t._v("#")]),t._v(" 组件中data为什么是个函数")]),t._v(" "),a("p",[t._v("组件是可复用的vue实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的，基于这一理念，组件每复用一次，data数据就应该被复制一次，之后，当某一处复用的地方组件内data数据被改变时，其他复用地方组件的data数据不受影响。")]),t._v(" "),a("h2",{attrs:{id:"vue中-key-值的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中-key-值的作用"}},[t._v("#")]),t._v(" vue中 key 值的作用")]),t._v(" "),a("p",[t._v("当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。")]),t._v(" "),a("h2",{attrs:{id:"keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[t._v("#")]),t._v(" keep-alive")]),t._v(" "),a("p",[t._v("keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。")]),t._v(" "),a("h2",{attrs:{id:"vue-router"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router"}},[t._v("#")]),t._v(" vue-router")]),t._v(" "),a("ul",[a("li",[t._v("路由的两种模式：history, hash")]),t._v(" "),a("li",[t._v("传参：params, query")])]),t._v(" "),a("h2",{attrs:{id:"vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[t._v("#")]),t._v(" Vuex")]),t._v(" "),a("ul",[a("li",[t._v("Vuex 是什么？\n"),a("ul",[a("li",[t._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。")])])]),t._v(" "),a("li",[t._v("核心概念:\n"),a("ul",[a("li",[t._v("State\n"),a("ul",[a("li",[t._v("Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。")])])]),t._v(" "),a("li",[t._v("Getter\n"),a("ul",[a("li",[t._v("类似vue的计算属性，主要用来过滤一些数据。")])])]),t._v(" "),a("li",[t._v("Mutation\n"),a("ul",[a("li",[t._v("定义方法动态修改Vuex 的 store 中的状态或数据。")])])]),t._v(" "),a("li",[t._v("Action\n"),a("ul",[a("li",[t._v("通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。")])])]),t._v(" "),a("li",[t._v("Module\n"),a("ul",[a("li",[t._v("项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。")])])])])]),t._v(" "),a("li",[t._v("Mutation与Action区别\n"),a("ul",[a("li",[t._v("Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。")])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);